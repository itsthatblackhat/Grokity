# Grokity Game Engine

## Overview

The Grokity Game Engine is a powerful and flexible JavaScript-based engine designed for creating 3D browser games. It integrates multiple technologies, including Three.js for graphics and Cannon.js for physics, to deliver a seamless development experience. The engine is modular, with components and managers that handle different aspects of the game development process, allowing developers to easily customize and extend the engine's functionality.

## Features

- **Three.js Integration**: Utilizes Three.js for high-quality 3D graphics rendering.
- **Cannon.js Physics**: Implements Cannon.js for realistic physics simulations.
- **Modular Architecture**: Organized into various managers and components for better maintainability and scalability.
- **Asset Management**: Efficiently handles the loading and management of game assets.
- **Input Handling**: Supports multiple input methods, including keyboard, mouse, and game controllers.
- **Dogenites**: A unique feature that allows the engine to recreate any image with high accuracy and performance using 3D triangular tiles.

## Project Structure

The project is structured into various directories, each handling a specific part of the engine's functionality:

- `Core`: Contains the core components and managers of the engine.
- `Common`: Includes common libraries and utilities.
- `Examples`: Demonstrates how to use the engine to create different types of games.
- `GrokityAssetMan`: Manages game assets such as textures and models.
- `GrokityEditor`: Tools and editors for creating and managing game content.
- `Managers`: Additional managers for various functionalities.

## Installation

To get started with the Grokity Game Engine, follow these steps:

1. Clone the repository:
    git clone https://github.com/your-username/grokity-game-engine.git
    cd grokity-game-engine
    

2. Install dependencies:
    npm install

3. Build the project:
    npm run build

4. Start the development server:
    npm start

5. Open your browser and navigate to `http://localhost:8080`.

## Using Dogenites

### Overview

Dogenites are a unique feature of the Grokity Game Engine that allow you to recreate any image with extreme accuracy and no latency. This is achieved by breaking down the image into small triangular tiles and rendering them in 3D space.

### Technical Details

The Dogenite rendering process involves the following steps:

1. **Image Loading**: Load the image texture using Three.js's `TextureLoader`.
2. **Image Processing**: Extract pixel data from the image and create a canvas for pixel manipulation.
3. **Dogenite Creation**: For each pixel with non-zero alpha, create a Dogenite (a small triangular tile) with the corresponding color.
4. **Instanced Rendering**: Use Three.js's `InstancedMesh` to efficiently render thousands of Dogenites with minimal performance overhead.

### Example

Here's an example of how to create and render Dogenites from an image:

#### `DogeniteAlgo.js`

import * as THREE from 'three';

export function createDogenitesFromImage(texture) {
    const width = texture.image.width;
    const height = texture.image.height;
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    const context = canvas.getContext('2d');
    context.drawImage(texture.image, 0, 0);
    const imageData = context.getImageData(0, 0, width, height);

    const dogeniteGeometry = new THREE.BufferGeometry();
    const vertices = new Float32Array([
        -0.5, -0.5, 0,
        0.5, -0.5, 0,
        0, 0.5, 0
    ]);
    dogeniteGeometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));

    const count = width * height;
    const mesh = new THREE.InstancedMesh(dogeniteGeometry, new THREE.MeshBasicMaterial({ side: THREE.DoubleSide }), count);

    let index = 0;

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const pixelIndex = (y * width + x) * 4;
            const alpha = imageData.data[pixelIndex + 3];

            if (alpha > 0) {
                const color = new THREE.Color(
                    imageData.data[pixelIndex] / 255,
                    imageData.data[pixelIndex + 1] / 255,
                    imageData.data[pixelIndex + 2] / 255
                );

                const material = new THREE.MeshBasicMaterial({ color: color, side: THREE.DoubleSide });
                mesh.setColorAt(index, color);

                const matrix = new THREE.Matrix4();
                matrix.setPosition(x - width / 2, y - height / 2, 0);
                mesh.setMatrixAt(index, matrix);

                index++;
            }
        }
    }

    mesh.instanceMatrix.needsUpdate = true;
    mesh.count = index;

    return mesh;
}

### ---------------------------

### World.js

import * as THREE from 'three';
import { createDogenitesFromImage } from '/Core/Dogenite/DogeniteAlgo.js';
import AssetManager from '/GrokityAssetMan/AssetManager.js';

class World {
    constructor(scene) {
        this.scene = scene;
        this.dogenites = null;
    }

    async init() {
        try {
            console.log('Preloading assets...');
            await AssetManager.preloadAssets(['assets/Dogecoin.png']);
            const dogecoinTexture = AssetManager.getTexture('assets/Dogecoin.png');

            if (!dogecoinTexture) {
                throw new Error('Texture not loaded');
            }

            console.log('Creating Dogenites...');
            this.dogenites = createDogenitesFromImage(dogecoinTexture);
            this.dogenites.position.set(0, 0, -50); // Position in front of the camera

            console.log('Adding Dogenites to the scene...');
            this.scene.add(this.dogenites);
        } catch (error) {
            console.error('Error initializing World:', error);
        }
    }

    update(deltaTime) {
        // Update logic if necessary
    }
}

export default World;


## Achievements
Creating the Dogenite rendering system involved several key techniques and optimizations:

- Canvas Manipulation: Used HTML canvas to extract pixel data and colors from images.
- Instanced Rendering: Leveraged Three.js's InstancedMesh for efficient rendering of thousands of Dogenites.
- Color Matching: Ensured that each Dogenite matched the exact color of the corresponding pixel from the source image.
- Performance Optimization: Focused on minimizing performance overhead to achieve smooth rendering without latency.


